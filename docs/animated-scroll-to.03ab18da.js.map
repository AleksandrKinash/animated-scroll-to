{"version":3,"sources":["src/animated-scroll-to.ts"],"names":[],"mappings":"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","file":"animated-scroll-to.03ab18da.js","sourceRoot":"..","sourcesContent":["export type TCoords = [number | null, number | null];\n\nexport interface IOptions {\n  cancelOnUserAction?: boolean\n  easing?: (t:number) => number\n  elementToScroll?: Element | Window\n  horizontalOffset?: number\n  maxDuration?: number\n  minDuration?: number\n  passive?: boolean\n  speed?: number\n  verticalOffset?: number\n}\n\n// --------- SCROLL INTERFACES\n\nfunction getElementOffset(el) {\n  let top = 0;\n  let left = 0;\n  let element = el;\n\n  // Loop through the DOM tree\n  // and add it's parent's offset to get page offset\n  do {\n    top += element.offsetTop || 0;\n    left += element.offsetLeft || 0;\n    element = element.offsetParent;\n  } while (element);\n\n  return {\n    top,\n    left,\n  };\n}\n\n// --------- SCROLL INTERFACES\n\n// ScrollDomElement and ScrollWindow have identical interfaces\n\nclass ScrollDomElement {\n  element:Element\n\n  constructor(element:Element) {\n    this.element = element;\n  }\n\n  getHorizontalScroll():number {\n    return this.element.scrollLeft;\n  }\n\n  getVerticalScroll():number {\n    return this.element.scrollTop;\n  }\n\n  getMaxHorizontalScroll():number {\n    return this.element.scrollWidth - this.element.clientWidth;\n  }\n\n  getMaxVerticalScroll():number {\n    return this.element.scrollHeight - this.element.clientHeight;\n  }\n\n  getHorizontalElementScrollOffset(elementToScrollTo:Element, elementToScroll:Element):number {\n    return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;\n  }\n\n  getVerticalElementScrollOffset(elementToScrollTo:Element, elementToScroll:Element):number {\n    return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;\n  }\n\n  scrollTo(x:number, y:number) {\n    this.element.scrollLeft = x;\n    this.element.scrollTop = y;\n  }\n}\n\nclass ScrollWindow {\n  getHorizontalScroll():number {\n    return window.scrollX || document.documentElement.scrollLeft;\n  }\n\n  getVerticalScroll():number {\n    return window.scrollY || document.documentElement.scrollTop;\n  }\n\n  getMaxHorizontalScroll():number {\n    return Math.max(\n      document.body.scrollWidth, document.documentElement.scrollWidth,\n      document.body.offsetWidth, document.documentElement.offsetWidth,\n      document.body.clientWidth, document.documentElement.clientWidth\n    ) - window.innerWidth;\n  }\n\n  getMaxVerticalScroll():number {\n    return Math.max(\n      document.body.scrollHeight, document.documentElement.scrollHeight,\n      document.body.offsetHeight, document.documentElement.offsetHeight,\n      document.body.clientHeight, document.documentElement.clientHeight\n    ) - window.innerHeight;\n  }\n\n  getHorizontalElementScrollOffset(elementToScrollTo:Element):number {\n    const scrollLeft = window.scrollX || document.documentElement.scrollLeft;\n    return scrollLeft + elementToScrollTo.getBoundingClientRect().left;\n  }\n\n  getVerticalElementScrollOffset(elementToScrollTo:Element):number {\n    const scrollTop = window.scrollY || document.documentElement.scrollTop;\n    return scrollTop + elementToScrollTo.getBoundingClientRect().top;\n  }\n\n  scrollTo(x:number, y:number) {\n    window.scrollTo(x, y)\n  }\n}\n\n// --------- KEEPING TRACK OF ACTIVE ANIMATIONS\n\nconst activeAnimations = {\n  elements: [],\n  cancelMethods: [],\n\n  add: (element:Element | Window, cancelAnimation:() => void) => {\n    activeAnimations.elements.push(element);\n    activeAnimations.cancelMethods.push(cancelAnimation);\n  },\n  remove: (element:Element | Window, shouldStop:boolean = true) => {\n    const index = activeAnimations.elements.indexOf(element);\n\n    if (index > -1) {\n      // Stop animation\n      if (shouldStop) {\n        activeAnimations.cancelMethods[index]();\n      }\n      // Remove it\n      activeAnimations.elements.splice(index, 1);\n      activeAnimations.cancelMethods.splice(index, 1);\n    }\n  }\n};\n\n// --------- CHECK IF CODE IS RUNNING IN A BROWSER\n\nconst WINDOW_EXISTS = typeof window !== 'undefined';\n\n// --------- ANIMATE SCROLL TO\n\nconst defaultOptions:IOptions = {\n  cancelOnUserAction: true,\n  easing: t => (--t) * t * t + 1, // easeOutCubic\n  elementToScroll: WINDOW_EXISTS ? window : null, // Check for server side rendering\n  horizontalOffset: 0,\n  maxDuration: 3000,\n  minDuration: 250,\n  speed: 500,\n  verticalOffset: 0,\n};\n\nfunction animateScrollTo(y:number, userOptions?:IOptions);\nfunction animateScrollTo(coords:TCoords, userOptions?:IOptions);\nfunction animateScrollTo(scrollToElement: Element, userOptions?:IOptions);\nfunction animateScrollTo(\n  numberOrCoordsOrElement: number | TCoords | Element,\n  userOptions: IOptions = {}\n) {\n  // Check for server rendering\n  if (!WINDOW_EXISTS) {\n    // @ts-ignore\n    // If it still gets called on server, return Promise for API consistency\n    return new Promise((resolve:(hasScrolledToPosition:boolean) => void) => {\n      resolve(false); // Returning false on server\n    });\n  } else if (!(window as any).Promise){\n    throw(\n      'Browser doesn\\'t support Promises, and animated-scroll-to depends on it, please provide a polyfill.'\n    );\n  }\n\n  let x:number | null;\n  let y:number | null;\n  let scrollToElement:Element; \n  let options:IOptions = { \n    ...defaultOptions, \n    ...userOptions, \n  }; \n\n  const isWindow = options.elementToScroll === window;\n  const isElement = !!(options.elementToScroll as Element).nodeName;\n\n  if (!isWindow && !isElement) {\n    throw(\n      'Element to scroll needs to be either window or DOM element.'\n    );\n  }\n\n  const elementToScroll = isWindow ? \n    new ScrollWindow() : \n    new ScrollDomElement(options.elementToScroll as Element);\n\n  if (numberOrCoordsOrElement instanceof Element) {\n    scrollToElement = numberOrCoordsOrElement;\n\n    // If \"elementToScroll\" is not a parent of \"scrollToElement\"\n    if (\n      isElement && \n      (\n        !(options.elementToScroll as Element).contains(scrollToElement) ||\n        (options.elementToScroll as Element).isSameNode(scrollToElement)\n      )\n    ) {\n      throw(\n        'options.elementToScroll has to be a parent of scrollToElement'\n      );\n    }\n\n    x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, (options.elementToScroll as Element));\n    y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, (options.elementToScroll as Element));\n  } else if (typeof numberOrCoordsOrElement === 'number') {\n    x = elementToScroll.getHorizontalScroll();\n    y = numberOrCoordsOrElement;\n  } else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {\n    x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];\n    y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];\n  } else {\n    // ERROR\n    throw(\n      'Wrong function signature. Check documentation.\\n' + \n      'Available method signatures are:\\n' +\n      '  animateScrollTo(y:number, options)\\n' + \n      '  animateScrollTo([x:number | null, y:number | null], options)\\n' + \n      '  animateScrollTo(scrollToElement:Element, options)'\n    );\n  }\n\n  // Add offsets\n  x += options.horizontalOffset;\n  y += options.verticalOffset;\n\n\n  // Horizontal scroll distance\n  const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();\n  const initialHorizontalScroll = elementToScroll.getHorizontalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (x > maxHorizontalScroll) {\n    x = maxHorizontalScroll;\n  }\n\n  // Calculate distance to scroll\n  const horizontalDistanceToScroll = x - initialHorizontalScroll;\n\n  // Vertical scroll distance distance\n  const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();\n  const initialVerticalScroll = elementToScroll.getVerticalScroll();\n\n  // If user specified scroll position is greater than maximum available scroll\n  if (y > maxVerticalScroll) {\n    y = maxVerticalScroll;\n  }\n\n  // Calculate distance to scroll\n  const verticalDistanceToScroll = y - initialVerticalScroll;\n\n  // Calculate duration of the scroll\n  const horizontalDuration = Math.abs(Math.round((horizontalDistanceToScroll / 1000) * options.speed));\n  const verticalDuration = Math.abs(Math.round((verticalDistanceToScroll / 1000) * options.speed));\n\n  let duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;\n\n  // Set minimum and maximum duration\n  if (duration < options.minDuration) {\n    duration = options.minDuration;\n  } else if (duration > options.maxDuration) {\n    duration = options.maxDuration;\n  }\n\n  // @ts-ignore\n  return new Promise((resolve:(hasScrolledToPosition:boolean) => void, reject) => {\n    // Scroll is already in place, nothing to do\n    if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) {\n      // Resolve promise with a boolean hasScrolledToPosition set to true\n      resolve(true);\n    }\n\n    // Cancel existing animation if it is already running on the same element\n    activeAnimations.remove(options.elementToScroll, true);\n\n    // To cancel animation we have to store request animation frame ID \n    let requestID;\n\n    // Cancel animation handler\n    const cancelAnimation = () => {\n      removeListeners();\n      cancelAnimationFrame(requestID);\n\n      // Resolve promise with a boolean hasScrolledToPosition set to false\n      resolve(false);\n    };\n\n    // Registering animation so it can be canceled if function\n    // gets called again on the same element\n    activeAnimations.add(options.elementToScroll, cancelAnimation);\n\n    // Prevent user actions handler\n    const preventDefaultHandler = e => e.preventDefault();\n    \n    const handler = options.cancelOnUserAction ? \n      cancelAnimation : \n      preventDefaultHandler;\n\n    // If animation is not cancelable by the user, we can't use passive events\n    const eventOptions: any = options.cancelOnUserAction ?\n      { passive: true } :\n      { passive: false };\n\n    const events = [\n      'wheel',\n      'touchstart',\n      'keydown',\n      'mousedown',\n    ];\n\n    // Function to remove listeners after animation is finished\n    const removeListeners = () => {\n      events.forEach(eventName => {\n        options.elementToScroll.removeEventListener(eventName, handler, eventOptions);\n      });\n    };\n\n    // Add listeners\n    events.forEach(eventName => {\n      options.elementToScroll.addEventListener(eventName, handler, eventOptions);\n    });\n\n    // Animation\n    const startingTime = Date.now();\n\n    const step = () => {\n      var timeDiff = Date.now() - startingTime;\n      var t = timeDiff / duration;\n      \n      const horizontalScrollPosition = Math.round(initialHorizontalScroll + (horizontalDistanceToScroll * options.easing(t)));\n      const verticalScrollPosition = Math.round(initialVerticalScroll + (verticalDistanceToScroll * options.easing(t)));\n      \n      if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {\n        // If scroll didn't reach desired position or time is not elapsed\n        // Scroll to a new position\n        elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);\n\n        // And request a new step\n        requestID = requestAnimationFrame(step);\n      } else {\n        // If the time elapsed or we reached the desired offset\n        // Set scroll to the desired offset (when rounding made it to be off a pixel or two)\n        // Clear animation frame to be sure\n        elementToScroll.scrollTo(x, y);\n\n        cancelAnimationFrame(requestID);\n\n        // Remove listeners\n        removeListeners();\n\n        // Remove animation from the active animations coordinator\n        activeAnimations.remove(options.elementToScroll, false);\n        \n        // Resolve promise with a boolean hasScrolledToPosition set to true\n        resolve(true);\n      }\n    };\n\n    // Start animating scroll\n    requestID = requestAnimationFrame(step);\n  });\n}\n\nexport default animateScrollTo;\n\n// Support for direct usage in browsers\n// This is mostly to keep it similar to v1\n// Don't forget to include Promise polyfill for IE\n// <script src=\"https://unpkg.com/es6-promise/dist/es6-promise.auto.min.js\"></script>\n// https://github.com/stefanpenner/es6-promise\nif (WINDOW_EXISTS) {\n  (window as any).animateScrollTo = animateScrollTo;\n}\n\n"]}